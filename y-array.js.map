{"version":3,"file":"y-array.js","sources":["src/y-array.js"],"sourcesContent":["/* global Y */\n\nfunction extend (Y) {\n  Y.utils.yarrayEventHandler = function (op) {\n    if (op.struct === 'Insert') {\n      // when using indexeddb db adapter, the op could already exist (see y-js/y-indexeddb#2)\n      if (this._content.some(function (c) { return Y.utils.compareIds(c.id, op.id) })) {\n        // op exists\n        return\n      }\n      let pos\n      // we check op.left only!,\n      // because op.right might not be defined when this is called\n      if (op.left === null) {\n        pos = 0\n      } else {\n        pos = 1 + this._content.findIndex(function (c) {\n          return Y.utils.compareIds(c.id, op.left)\n        })\n        if (pos <= 0) {\n          throw new Error('Unexpected operation!')\n        }\n      }\n\n      /*\n      (see above for new approach)\n      var _e = this._content[pos]\n      // when using indexeddb db adapter, the op could already exist (see y-js/y-indexeddb#2)\n      // If the algorithm works correctly, the double should always exist on the correct position (pos - the computed destination)\n      if (_e != null && Y.utils.compareIds(_e.id, op.id)) {\n        // is already defined\n        return\n      }\n      */\n      var values\n      var length\n      if (op.hasOwnProperty('opContent')) {\n        this._content.splice(pos, 0, {\n          id: op.id,\n          type: op.opContent\n        })\n        length = 1\n        let type = this.os.getType(op.opContent)\n        type._parent = this._model\n        values = [type]\n      } else {\n        var contents = op.content.map(function (c, i) {\n          return {\n            id: [op.id[0], op.id[1] + i],\n            val: c\n          }\n        })\n        // insert value in _content\n        // It is not possible to insert more than ~2^16 elements in an Array (see #5). We handle this case explicitly\n        if (contents.length < 30000) {\n          this._content.splice.apply(this._content, [pos, 0].concat(contents))\n        } else {\n          this._content = this._content.slice(0, pos).concat(contents).concat(this._content.slice(pos))\n        }\n        values = op.content\n        length = op.content.length\n      }\n      Y.utils.bubbleEvent(this, {\n        type: 'insert',\n        object: this,\n        index: pos,\n        values: values,\n        length: length\n      })\n    } else if (op.struct === 'Delete') {\n      var i = 0 // current position in _content\n      for (; i < this._content.length && op.length > 0; i++) {\n        var c = this._content[i]\n        if (Y.utils.inDeletionRange(op, c.id)) {\n          // is in deletion range!\n          var delLength\n          // check how many character to delete in one flush\n          for (delLength = 1;\n                delLength < op.length && i + delLength < this._content.length && Y.utils.inDeletionRange(op, this._content[i + delLength].id);\n                delLength++) {}\n          // last operation that will be deleted\n          c = this._content[i + delLength - 1]\n          // update delete operation\n          op.length -= c.id[1] - op.target[1] + 1\n          op.target = [c.id[0], c.id[1] + 1]\n          // apply deletion & find send event\n          let content = this._content.splice(i, delLength)\n          let values = content.map((c) => {\n            if (c.val != null) {\n              return c.val\n            } else {\n              return this.os.getType(c.type)\n            }\n          })\n          Y.utils.bubbleEvent(this, {\n            type: 'delete',\n            object: this,\n            index: i,\n            values: values,\n            _content: content,\n            length: delLength\n          })\n          // with the fresh delete op, we can continue\n          // note: we don't have to increment i, because the i-th content was deleted\n          // but on the other had, the (i+delLength)-th was not in deletion range\n          // So we don't do i--\n        }\n      }\n    } else {\n      throw new Error('Unexpected struct!')\n    }\n  }\n  class YArray extends Y.utils.CustomType {\n    constructor (os, _model, _content) {\n      super()\n      this.os = os\n      this._model = _model\n      // Array of all the neccessary content\n      this._content = _content\n      // the parent of this type\n      this._parent = null\n      this._deepEventHandler = new Y.utils.EventListenerHandler()\n      this.eventHandler = new Y.utils.EventHandler(Y.utils.yarrayEventHandler.bind(this))\n    }\n    _getPathToChild (childId) {\n      return this._content.findIndex(c =>\n        c.type != null && Y.utils.compareIds(c.type, childId)\n      )\n    }\n    _destroy () {\n      this.eventHandler.destroy()\n      this.eventHandler = null\n      this._content = null\n      this._model = null\n      this._parent = null\n      this.os = null\n    }\n    get length () {\n      return this._content.length\n    }\n    toJSON () {\n      return this._content.map(x => {\n        if (x.type != null) {\n          let type = this.os.getType(x.type)\n          if (type.toJSON != null) {\n            return type.toJSON()\n          } else if (type.toString != null) {\n            return type.toString()\n          } else {\n            return undefined\n          }\n        } else {\n          return x.val\n        }\n      })\n    }\n    get (pos) {\n      if (pos == null || typeof pos !== 'number') {\n        throw new Error('pos must be a number!')\n      }\n      if (pos >= this._content.length) {\n        return undefined\n      }\n      if (this._content[pos].type == null) {\n        return this._content[pos].val\n      } else {\n        return this.os.getType(this._content[pos].type)\n      }\n    }\n    toArray () {\n      return this._content.map((x, i) => {\n        if (x.type != null) {\n          return this.os.getType(x.type)\n        } else {\n          return x.val\n        }\n      })\n    }\n    push (contents) {\n      return this.insert(this._content.length, contents)\n    }\n    insert (pos, contents) {\n      if (typeof pos !== 'number') {\n        throw new Error('pos must be a number!')\n      }\n      if (!Array.isArray(contents)) {\n        throw new Error('contents must be an Array of objects!')\n      }\n      if (contents.length === 0) {\n        return\n      }\n      if (pos > this._content.length || pos < 0) {\n        throw new Error('This position exceeds the range of the array!')\n      }\n      var mostLeft = pos === 0 ? null : this._content[pos - 1].id\n\n      var ops = []\n      var prevId = mostLeft\n      for (var i = 0; i < contents.length;) {\n        var op = {\n          left: prevId,\n          origin: prevId,\n          // right: mostRight,\n          // NOTE: I intentionally do not define right here, because it could be deleted\n          // at the time of inserting this operation (when we get the transaction),\n          // and would therefore not defined in this._content\n          parent: this._model,\n          struct: 'Insert'\n        }\n        var _content = []\n        var typeDefinition\n        while (i < contents.length) {\n          var val = contents[i++]\n          typeDefinition = Y.utils.isTypeDefinition(val)\n          if (!typeDefinition) {\n            _content.push(val)\n          } else if (_content.length > 0) {\n            i-- // come back again later\n            break\n          } else {\n            break\n          }\n        }\n        if (_content.length > 0) {\n          // content is defined\n          op.content = _content\n          op.id = this.os.getNextOpId(_content.length)\n        } else {\n          // otherwise its a type\n          var typeid = this.os.getNextOpId(1)\n          this.os.createType(typeDefinition, typeid)\n          op.opContent = typeid\n          op.id = this.os.getNextOpId(1)\n        }\n        ops.push(op)\n        prevId = op.id\n      }\n      var eventHandler = this.eventHandler\n      this.os.requestTransaction(function () {\n        // now we can set the right reference.\n        var mostRight\n        if (mostLeft != null) {\n          var ml = this.getInsertionCleanEnd(mostLeft)\n          mostRight = ml.right\n        } else {\n          mostRight = (this.getOperation(ops[0].parent)).start\n        }\n        for (var j = 0; j < ops.length; j++) {\n          var op = ops[j]\n          op.right = mostRight\n        }\n        eventHandler.awaitOps(this, this.applyCreatedOperations, [ops])\n      })\n      // always remember to do that after this.os.requestTransaction\n      // (otherwise values might contain a undefined reference to type)\n      eventHandler.awaitAndPrematurelyCall(ops)\n    }\n    delete (pos, length) {\n      if (length == null) { length = 1 }\n      if (typeof length !== 'number') {\n        throw new Error('length must be a number!')\n      }\n      if (typeof pos !== 'number') {\n        throw new Error('pos must be a number!')\n      }\n      if (pos + length > this._content.length || pos < 0 || length < 0) {\n        throw new Error('The deletion range exceeds the range of the array!')\n      }\n      if (length === 0) {\n        return\n      }\n      var eventHandler = this.eventHandler\n      var dels = []\n      var delLength\n      for (var i = 0; i < length; i = i + delLength) {\n        var targetId = this._content[pos + i].id\n        // how many insertions can we delete in one deletion?\n        for (delLength = 1; i + delLength < length; delLength++) {\n          if (!Y.utils.compareIds(this._content[pos + i + delLength].id, [targetId[0], targetId[1] + delLength])) {\n            break\n          }\n        }\n        dels.push({\n          target: targetId,\n          struct: 'Delete',\n          length: delLength\n        })\n      }\n      this.os.requestTransaction(function () {\n        eventHandler.awaitOps(this, this.applyCreatedOperations, [dels])\n      })\n      // always remember to do that after this.os.requestTransaction\n      // (otherwise values might contain a undefined reference to type)\n      eventHandler.awaitAndPrematurelyCall(dels)\n    }\n    observe (f) {\n      this.eventHandler.addEventListener(f)\n    }\n    observeDeep (f) {\n      this._deepEventHandler.addEventListener(f)\n    }\n    unobserve (f) {\n      this.eventHandler.removeEventListener(f)\n    }\n    unobserveDeep (f) {\n      this._deepEventHandler.removeEventListener(f)\n    }\n    _changed (transaction, op) {\n      if (!op.deleted) {\n        if (op.struct === 'Insert') {\n          // update left\n          var l = op.left\n          var left\n          while (l != null) {\n            left = transaction.getInsertion(l)\n            if (!left.deleted) {\n              break\n            }\n            l = left.left\n          }\n          op.left = l\n          // if op contains opContent, initialize it\n          if (op.opContent != null) {\n            transaction.store.initType.call(transaction, op.opContent)\n          }\n        }\n        this.eventHandler.receivedOp(op)\n      }\n    }\n  }\n\n  Y.extend('Array', new Y.utils.CustomTypeDefinition({\n    name: 'Array',\n    class: YArray,\n    struct: 'List',\n    initType: function YArrayInitializer (os, model) {\n      var _content = []\n      var _types = []\n      Y.Struct.List.map.call(this, model, function (op) {\n        if (op.hasOwnProperty('opContent')) {\n          _content.push({\n            id: op.id,\n            type: op.opContent\n          })\n          _types.push(op.opContent)\n        } else {\n          op.content.forEach(function (c, i) {\n            _content.push({\n              id: [op.id[0], op.id[1] + i],\n              val: op.content[i]\n            })\n          })\n        }\n      })\n      for (var i = 0; i < _types.length; i++) {\n        let type = this.store.initType.call(this, _types[i])\n        type._parent = model.id\n      }\n      return new YArray(os, model.id, _content)\n    },\n    createType: function YArrayCreateType (os, model) {\n      return new YArray(os, model.id, [])\n    }\n  }))\n}\n\nexport default extend\nif (typeof Y !== 'undefined') {\n  extend(Y)\n}\n"],"names":["extend","Y","utils","yarrayEventHandler","op","struct","this","_content","some","c","compareIds","id","pos","left","findIndex","Error","values","length","hasOwnProperty","splice","opContent","type","os","getType","_parent","_model","contents","content","map","i","apply","concat","slice","bubbleEvent","inDeletionRange","delLength","target","val","_this","YArray","_deepEventHandler","EventListenerHandler","eventHandler","EventHandler","bind","childId","destroy","x","_this3","toJSON","toString","_this4","insert","Array","isArray","mostLeft","ops","prevId","typeDefinition","isTypeDefinition","push","getNextOpId","typeid","createType","requestTransaction","mostRight","getInsertionCleanEnd","right","getOperation","parent","start","j","awaitOps","applyCreatedOperations","awaitAndPrematurelyCall","dels","targetId","f","addEventListener","removeEventListener","transaction","deleted","l","getInsertion","store","initType","call","receivedOp","CustomType","CustomTypeDefinition","model","_types","Struct","List","forEach"],"mappings":"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"}